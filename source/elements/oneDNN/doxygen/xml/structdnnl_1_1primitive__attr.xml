<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="structdnnl_1_1primitive__attr" kind="struct" language="C++" prot="public">
    <compoundname>dnnl::primitive_attr</compoundname>
    <includes refid="dnnl_8hpp" local="no">dnnl.hpp</includes>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1acfbfd85b7ca82bf97e2b07c2427427de" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>dnnl::primitive_attr::primitive_attr</definition>
        <argsstring>()</argsstring>
        <name>primitive_attr</name>
        <briefdescription>
<para>Constructs default (empty) primitive attributes. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="729" column="5"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1af4131b946ec3af3bc2974b603d30029b" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__dnnl__api__attributes_1gac24d40ceea0256c7d6cc3a383a0fa07f" kindref="member">scratchpad_mode</ref></type>
        <definition>scratchpad_mode dnnl::primitive_attr::get_scratchpad_mode</definition>
        <argsstring>() const</argsstring>
        <name>get_scratchpad_mode</name>
        <briefdescription>
<para>Returns the scratchpad mode. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="732" column="21"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a91a597649afa13b7d2416b708d0620d2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::set_scratchpad_mode</definition>
        <argsstring>(scratchpad_mode mode)</argsstring>
        <name>set_scratchpad_mode</name>
        <param>
          <type><ref refid="group__dnnl__api__attributes_1gac24d40ceea0256c7d6cc3a383a0fa07f" kindref="member">scratchpad_mode</ref></type>
          <declname>mode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets scratchpad mode.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Specified scratchpad mode. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="737" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1aadcfc1f7a787a0b75d6b0daab8da14af" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::get_output_scales</definition>
        <argsstring>(int &amp;mask, std::vector&lt; float &gt; &amp;scales) const</argsstring>
        <name>get_output_scales</name>
        <param>
          <type>int &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>scales</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns output scaling factors correspondence mask and values.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Scaling factors correspondence mask that defines the correspondence between the output tensor dimensions and the <computeroutput>scales</computeroutput> vector. The set i-th bit indicates that a dedicated output scaling factor is used for each index along that dimension. The mask value of 0 implies a common output scaling factor for the whole output tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scales</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of output scaling factors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="748" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a4b81acc8e48886313154f75c1708ae02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::set_output_scales</definition>
        <argsstring>(int mask, const std::vector&lt; float &gt; &amp;scales)</argsstring>
        <name>set_output_scales</name>
        <param>
          <type>int</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>const std::vector&lt; float &gt; &amp;</type>
          <declname>scales</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets output scaling factors correspondence mask and values.</para>
<para>Example usage: <programlisting><codeline><highlight class="normal">int<sp/>mb<sp/>=<sp/>32,<sp/>oc<sp/>=<sp/>32,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>oh<sp/>=<sp/>14,<sp/>ow<sp/>=<sp/>14;<sp/>//<sp/>convolution<sp/>output<sp/>params</highlight></codeline>
<codeline><highlight class="normal">//<sp/>unique<sp/>output<sp/>scales<sp/>per<sp/>output<sp/>channel</highlight></codeline>
<codeline><highlight class="normal">vector&lt;float&gt;<sp/>scales<sp/>=<sp/>{<sp/>...<sp/>};</highlight></codeline>
<codeline><highlight class="normal">int<sp/>oc_dim<sp/>=<sp/>1;<sp/>//<sp/>mb_dim<sp/>=<sp/>0,<sp/>channel_dim<sp/>=<sp/>1,<sp/>height_dim<sp/>=<sp/>2,<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>construct<sp/>a<sp/>convolution<sp/>descriptor</highlight></codeline>
<codeline><highlight class="normal">dnnl::convolution::desc<sp/>conv_d;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">dnnl::primitive_attr<sp/>attr;</highlight></codeline>
<codeline><highlight class="normal">attr.set_output_scales(attr,<sp/>oc,<sp/>1<sp/>&lt;&lt;<sp/>oc_dim,<sp/>scales);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">dnnl::primitive_desc<sp/>conv_pd(conv_d,<sp/>attr,<sp/>engine);</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>The order of dimensions does not depend on how elements are laid out in memory. For example:<itemizedlist>
<listitem><para>for a 2D CNN activations tensor the order is always (n, c)</para>
</listitem><listitem><para>for a 4D CNN activations tensor the order is always (n, c, h, w)</para>
</listitem><listitem><para>for a 5D CNN weights tensor the order is always (g, oc, ic, kh, kw)</para>
</listitem></itemizedlist>
</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Defines the correspondence between the output tensor dimensions and the <computeroutput>scales</computeroutput> vector. The set i-th bit indicates that a dedicated scaling factor is used for each index along that dimension. Set the mask to 0 to use a common output scaling factor for the whole output tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scales</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant vector of output scaling factors. If the scaling factors are known at the time of this call, the following equality must hold: <formula id="3">$scales.size() = \prod\limits_{d \in mask} output.dims[d].$</formula> Violations can only be detected when the attributes are used to create a primitive descriptor. If the scaling factors are not known at the time of the call, this vector must contain a single <ref refid="group__dnnl__api__primitives__common_1gab16365c11b4dc88fbb453edb51f1979f" kindref="member">DNNL_RUNTIME_F32_VAL</ref> value and the output scaling factors must be passed at execution time as an argument with index <ref refid="group__dnnl__api__primitives__common_1ga0afb48b0c2b8f3ee30609aaa47aa29db" kindref="member">DNNL_ARG_ATTR_OUTPUT_SCALES</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="792" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a9fc7eb58cc958963a2d26743cfd5c763" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::get_scales</definition>
        <argsstring>(int arg, int &amp;mask, std::vector&lt; float &gt; &amp;scales) const</argsstring>
        <name>get_scales</name>
        <param>
          <type>int</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>std::vector&lt; float &gt; &amp;</type>
          <declname>scales</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns scaling factors correspondence mask and values for a given memory argument.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameter argument index as passed to the <ref refid="structdnnl_1_1primitive_1ae2704b0577f2eaad1043256d8d619bc5" kindref="member">primitive::execute()</ref> call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Scaling factors correspondence mask that defines the correspondence between the output tensor dimensions and the <computeroutput>scales</computeroutput> vector. The set i-th bit indicates that a dedicated scaling factor is used for each index along that dimension. Set the mask to 0 to use a common scaling factor for the whole output tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scales</parametername>
</parameternamelist>
<parameterdescription>
<para>Output vector of scaling factors. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="804" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a9bf717bd25b6fddd89055da8178eab75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::set_scales</definition>
        <argsstring>(int arg, int mask, const std::vector&lt; float &gt; &amp;scales)</argsstring>
        <name>set_scales</name>
        <param>
          <type>int</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>int</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>const std::vector&lt; float &gt; &amp;</type>
          <declname>scales</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets scaling factors for primitive operations for a given memory argument.</para>
<para><simplesect kind="see"><para><ref refid="structdnnl_1_1primitive__attr_1a4b81acc8e48886313154f75c1708ae02" kindref="member">dnnl::primitive_attr::set_output_scales</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameter argument index as passed to the <ref refid="structdnnl_1_1primitive_1ae2704b0577f2eaad1043256d8d619bc5" kindref="member">primitive::execute()</ref> call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Scaling factors correspondence mask that defines the correspondence between the tensor dimensions and the <computeroutput>scales</computeroutput> vector. The set i-th bit indicates that a dedicated scaling factor is used for each index along that dimension. Set the mask to 0 to use a common scaling factor for the whole output tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scales</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant vector of scaling factors. The following equality must hold: <formula id="4">$scales.size() = \prod\limits_{d \in mask} argument.dims[d].$</formula> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="821" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a010dfd54aa839ca1c0da892b99963bdf" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::get_zero_points</definition>
        <argsstring>(int arg, int &amp;mask, std::vector&lt; int32_t &gt; &amp;zero_points) const</argsstring>
        <name>get_zero_points</name>
        <param>
          <type>int</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>std::vector&lt; int32_t &gt; &amp;</type>
          <declname>zero_points</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns zero points correspondence mask and values.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameter argument index as passed to the <ref refid="structdnnl_1_1primitive_1ae2704b0577f2eaad1043256d8d619bc5" kindref="member">primitive::execute()</ref> call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Zero points correspondence mask that defines the correspondence between the output tensor dimensions and the <computeroutput>zero_points</computeroutput> vector. The set i-th bit indicates that a dedicated zero point is used for each index along that dimension. Set the mask to 0 to use a common zero point for the whole output tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zero_points</parametername>
</parameternamelist>
<parameterdescription>
<para>Output vector of zero points. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="833" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1aee82deb014cf9702ceb3e725156c25a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::set_zero_points</definition>
        <argsstring>(int arg, int mask, const std::vector&lt; int32_t &gt; &amp;zero_points)</argsstring>
        <name>set_zero_points</name>
        <param>
          <type>int</type>
          <declname>arg</declname>
        </param>
        <param>
          <type>int</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>const std::vector&lt; int32_t &gt; &amp;</type>
          <declname>zero_points</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets zero points for primitive operations for a given memory argument.</para>
<para><simplesect kind="see"><para><ref refid="structdnnl_1_1primitive__attr_1a4b81acc8e48886313154f75c1708ae02" kindref="member">dnnl::primitive_attr::set_output_scales</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Parameter argument index as passed to the <ref refid="structdnnl_1_1primitive_1ae2704b0577f2eaad1043256d8d619bc5" kindref="member">primitive::execute()</ref> call. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Zero point correspondence mask that defines the correspondence between the tensor dimensions and the <computeroutput>zero_points</computeroutput> vector. The set i-th bit indicates that a dedicated zero point is used for each index along that dimension. Set the mask to 0 to use a common zero point for the whole output tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>zero_points</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant vector of zero points. If the zero points are known at the time of this call, the following equality must hold: <formula id="5">$zero\_points.size() = \prod\limits_{d \in mask} argument.dims[d].$</formula> If the zero points are not known at the time of the call, this vector must contain a single <ref refid="group__dnnl__api__primitives__common_1gab16365c11b4dc88fbb453edb51f1979f" kindref="member">DNNL_RUNTIME_F32_VAL</ref> value and the zero points must be passed at execution time as an argument with index <ref refid="group__dnnl__api__primitives__common_1gaf8d879adfe2baa2f9f2a5143a0f274b6" kindref="member">DNNL_ARG_ATTR_ZERO_POINTS</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="855" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a05664ef63c94acbcc59e921c4a4da6b8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="structdnnl_1_1post__ops" kindref="compound">post_ops</ref></type>
        <definition>const post_ops dnnl::primitive_attr::get_post_ops</definition>
        <argsstring>() const</argsstring>
        <name>get_post_ops</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns post-ops previously set via <ref refid="structdnnl_1_1primitive__attr_1ac830fa9f4fcf480b494d73153ad579bf" kindref="member">set_post_ops()</ref>.</para>
<para><simplesect kind="return"><para>Post-ops. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="861" column="20"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1ac830fa9f4fcf480b494d73153ad579bf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::set_post_ops</definition>
        <argsstring>(const post_ops ops)</argsstring>
        <name>set_post_ops</name>
        <param>
          <type>const <ref refid="structdnnl_1_1post__ops" kindref="compound">post_ops</ref></type>
          <declname>ops</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets post-ops.</para>
<para><simplesect kind="note"><para>There is no way to check whether the post-ops would be supported by the target primitive. Any error will be reported by the respective primitive descriptor constructor.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>Post-ops object to copy post-ops from. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="871" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a39ce5aa8b06ed331d8e2158108cc8324" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::set_rnn_data_qparams</definition>
        <argsstring>(float scale, float shift)</argsstring>
        <name>set_rnn_data_qparams</name>
        <param>
          <type>float</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>float</type>
          <declname>shift</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets quantization scale and shift parameters for RNN data tensors.</para>
<para>For performance reasons, the low-precision configuration of the RNN primitives expect input activations to have the unsigned 8-bit integer data type. The scale and shift parameters are used to quantize floating-point data to unsigned integer and must be passed to the RNN primitive using attributes.</para>
<para>The quantization formula is <computeroutput>scale * (data + shift)</computeroutput>.</para>
<para>Example usage: <programlisting><codeline><highlight class="normal">//<sp/>RNN<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal">int<sp/>l<sp/>=<sp/>2,<sp/>t<sp/>=<sp/>2,<sp/>mb<sp/>=<sp/>32,<sp/>sic<sp/>=<sp/>32,<sp/>slc<sp/>=<sp/>32,<sp/>dic<sp/>=<sp/>32,<sp/>dlc<sp/>=<sp/>32;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Activations<sp/>quantization<sp/>parameters</highlight></codeline>
<codeline><highlight class="normal">float<sp/>scale<sp/>=<sp/>2.0f,<sp/>shift<sp/>=<sp/>0.5f;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">primitive_attr<sp/>attr;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Set<sp/>scale<sp/>and<sp/>shift<sp/>for<sp/>int8<sp/>quantization<sp/>of<sp/>activation</highlight></codeline>
<codeline><highlight class="normal">attr.set_rnn_data_qparams(scale,<sp/>shift);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Create<sp/>and<sp/>configure<sp/>rnn<sp/>op_desc</highlight></codeline>
<codeline><highlight class="normal">vanilla_rnn_forward::desc<sp/>rnn_d(/*<sp/>arguments<sp/>*/);</highlight></codeline>
<codeline><highlight class="normal">vanilla_rnn_forward::primitive_desc<sp/>rnn_d(rnn_d,<sp/>attr,<sp/>engine);</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>Quantization scale and shift are common for src_layer, src_iter, dst_iter, and dst_layer.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>scale</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to scale the data by. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shift</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to shift the data by. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="906" column="10"/>
      </memberdef>
      <memberdef kind="function" id="structdnnl_1_1primitive__attr_1a61bd70f97baa628fd49b2c8b334b913e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void dnnl::primitive_attr::set_rnn_weights_qparams</definition>
        <argsstring>(int mask, const std::vector&lt; float &gt; &amp;scales)</argsstring>
        <name>set_rnn_weights_qparams</name>
        <param>
          <type>int</type>
          <declname>mask</declname>
        </param>
        <param>
          <type>const std::vector&lt; float &gt; &amp;</type>
          <declname>scales</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets quantization scaling factors for RNN weights tensors. The low-precision configuration of the RNN primitives expect input weights to use the signed 8-bit integer data type. The scaling factors are used to quantize floating-point data to signed integer and must be passed to RNN primitives using attributes.</para>
<para><simplesect kind="note"><para>The dimension order is always native and does not depend on the actual layout used. For example, five-dimensional weights always have (l, d, i, g, o) logical dimension ordering.</para>
</simplesect>
<simplesect kind="note"><para>Quantization scales are common for weights_layer and weights_iteration</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mask</parametername>
</parameternamelist>
<parameterdescription>
<para>Scaling factors correspondence mask that defines the correspondence between the output tensor dimensions and the <computeroutput>scales</computeroutput> vector. The set i-th bit indicates that a dedicated scaling factor should be used each index along that dimension. Set the mask to 0 to use a common scaling factor for the whole output tensor. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scales</parametername>
</parameternamelist>
<parameterdescription>
<para>Constant vector of output scaling factors. The following equality must hold: <formula id="6">$scales.size() = \prod\limits_{d \in mask} weights.dims[d].$</formula> Violations can only be detected when the attributes are used to create a primitive descriptor. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/dnnl.hpp" line="934" column="10"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Primitive attributes. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="include/dnnl.hpp" line="727" column="21" bodyfile="include/dnnl.hpp" bodystart="727" bodyend="935"/>
    <listofallmembers>
      <member refid="structdnnl_1_1primitive__attr_1aadcfc1f7a787a0b75d6b0daab8da14af" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>get_output_scales</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a05664ef63c94acbcc59e921c4a4da6b8" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>get_post_ops</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a9fc7eb58cc958963a2d26743cfd5c763" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>get_scales</name></member>
      <member refid="structdnnl_1_1primitive__attr_1af4131b946ec3af3bc2974b603d30029b" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>get_scratchpad_mode</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a010dfd54aa839ca1c0da892b99963bdf" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>get_zero_points</name></member>
      <member refid="structdnnl_1_1primitive__attr_1acfbfd85b7ca82bf97e2b07c2427427de" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>primitive_attr</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a4b81acc8e48886313154f75c1708ae02" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>set_output_scales</name></member>
      <member refid="structdnnl_1_1primitive__attr_1ac830fa9f4fcf480b494d73153ad579bf" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>set_post_ops</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a39ce5aa8b06ed331d8e2158108cc8324" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>set_rnn_data_qparams</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a61bd70f97baa628fd49b2c8b334b913e" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>set_rnn_weights_qparams</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a9bf717bd25b6fddd89055da8178eab75" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>set_scales</name></member>
      <member refid="structdnnl_1_1primitive__attr_1a91a597649afa13b7d2416b708d0620d2" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>set_scratchpad_mode</name></member>
      <member refid="structdnnl_1_1primitive__attr_1aee82deb014cf9702ceb3e725156c25a1" prot="public" virt="non-virtual"><scope>dnnl::primitive_attr</scope><name>set_zero_points</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
